<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Astro Dash: Gravity Switcher</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Consolidating Base Styles */
        html, body { height: 100%; }
        body {
            background-color: #0d1117; display: flex; justify-content: center; align-items: center;
            height: 100vh; margin: 0; font-family: 'Inter', sans-serif; overflow: hidden;
        }
        #gameContainer { width: 100%; height: 100%; display: flex; flex-direction: column; padding: 0; }
        #gameContentWrapper { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 10px; }
        .relative { flex-grow: 1; width: 100%; height: auto; display: flex; justify-content: center; align-items: center; padding: 10px; }
        #gameCanvas { display: block; background-color: transparent; border-radius: 8px; cursor: pointer; width: 100%; height: 100%; }
        
        /* Desktop/Laptop Specific Styles */
        @media (min-width: 1024px) {
            #gameContainer {
                max-width: 1200px; max-height: 800px; margin: auto;
                border: 2px solid #30363d; border-radius: 12px;
                box-shadow: 0 4px 15px rgba(0, 255, 255, 0.2); background-color: #161b22;
            }
        }
        
        /* Overlay/Button Styles */
        .game-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; border-radius: 8px; color: #ffffff; text-align: center; }
        .color-option { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 3px solid transparent; margin: 0 5px; transition: transform 0.1s; }
        input[type="radio"]:checked + .color-option { border-color: #ffffff; transform: scale(1.1); }
        #mobileFireButton { position: absolute; bottom: 20px; right: 20px; z-index: 15; width: 70px; height: 70px; border-radius: 50%; background-color: #ff0000; color: white; font-weight: bold; font-size: 14px; border: 4px solid #ff6666; box-shadow: 0 0 15px rgba(255, 0, 0, 0.8); user-select: none; touch-action: manipulation; }
    </style>
</head>
<body>

    <div id="gameContainer" class="mx-auto">
        <div class="flex justify-between items-center p-2 text-white font-bold text-base sm:text-lg">
            <h1 class="text-lg sm:text-xl font-extrabold text-cyan-400">Astro Dash</h1>
            <div class="flex items-center space-x-2 sm:space-x-4">
                <div id="highScoreDisplay" class="text-xs sm:text-base font-semibold text-gray-400">HI: 0</div>
                <div id="powerupStatusDisplay" class="text-xs sm:text-sm font-semibold text-orange-400 min-w-[120px] sm:min-w-[150px] text-right"></div>
                <div id="scoreDisplay" class="text-sm sm:text-base">Score: 0</div>
                <button id="pauseButton" class="px-2 py-0.5 bg-gray-700 hover:bg-gray-600 text-white text-xs sm:text-sm rounded-md shadow transition duration-150 transform hover:scale-105 hidden">Pause (P)</button>
            </div>
        </div>

        <div id="gameContentWrapper" class="relative">
            <canvas id="gameCanvas"></canvas>
            
            <div id="startScreen" class="game-overlay">
                <div class="text-4xl font-extrabold mb-8 text-cyan-400">CUSTOMIZE SHIP</div>
                
                <div class="mb-6">
                    <label class="block text-lg mb-2 font-semibold">Choose Shape:</label>
                    <div class="flex justify-center space-x-4 flex-wrap">
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="shape" value="square" checked class="form-radio text-cyan-500"><span class="text-white">Square (Default)</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="shape" value="circle" class="form-radio text-cyan-500"><span class="text-white">Circle</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="shape" value="triangle" class="form-radio text-cyan-500"><span class="text-white">Triangle</span></label>
                        <label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="shape" value="custom" class="form-radio text-cyan-500"><span class="text-white">Custom (JPG/PNG)</span></label>
                    </div>
                </div>

                <div id="customUploadContainer" class="mt-4 hidden w-full max-w-sm mx-auto p-2 bg-gray-800 rounded-lg">
                    <input type="file" id="customShipUpload" accept=".jpg, .jpeg, .png" class="text-sm w-full text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-cyan-50 file:text-cyan-700 hover:file:bg-cyan-100">
                    <p id="uploadMessage" class="text-xs mt-1 text-gray-400 text-left">Max 400KB file size.</p>
                </div>

                <div class="mb-8">
                    <label class="block text-lg mb-2 font-semibold">Choose Color:</label>
                    <div class="flex justify-center">
                        <label><input type="radio" name="color" value="#0ff" checked class="hidden"><div class="color-option" style="background-color: #0ff;"></div></label>
                        <label><input type="radio" name="color" value="#facc15" class="hidden"><div class="color-option" style="background-color: #facc15;"></div></label>
                        <label><input type="radio" name="color" value="#f43f5e" class="hidden"><div class="color-option" style="background-color: #f43f5e;"></div></label>
                        <label><input type="radio" name="color" value="#a78bfa" class="hidden"><div class="color-option" style="background-color: #a78bfa;"></div></label>
                    </div>
                </div>
                
                <div class="mb-6 text-center">
                    <label class="inline-flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" id="muteToggle" class="form-checkbox text-cyan-500 w-5 h-5 rounded" checked>
                        <span class="text-white font-semibold">Mute Sound</span>
                    </label>
                </div>

                <button id="startButton" class="px-8 py-4 bg-cyan-600 hover:bg-cyan-500 text-white font-bold text-xl rounded-lg shadow-xl transition duration-200 transform hover:scale-105">START GAME</button>
                <div class="text-sm mt-4 text-gray-400">Or press SPACE to start with default settings.</div>
            </div>

            <div id="gameOverScreen" class="game-overlay hidden">
                <div class="text-5xl font-extrabold mb-4 text-red-500">GAME OVER</div>
                <div id="finalScore" class="text-2xl mb-6 text-gray-200">Final Score: 0</div>
                <div class="flex space-x-4">
                    <button id="restartButton" class="px-6 py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded-lg shadow-lg transition duration-200 transform hover:scale-105">RESTART (SPACE)</button>
                    <button id="goHomeButton" class="px-6 py-3 bg-gray-600 hover:bg-gray-500 text-white font-bold rounded-lg shadow-lg transition duration-200 transform hover:scale-105">GO HOME</button>
                </div>
            </div>
            
            <div id="pauseScreen" class="game-overlay hidden">
                <div class="text-5xl font-extrabold mb-4 text-cyan-400">PAUSED</div>
                <div class="text-xl text-gray-200">Press P or click to Resume</div>
            </div>

            <button id="mobileFireButton" class="sm:hidden hidden">FIRE</button>

        </div>
        
        <div class="text-gray-400 text-sm mt-3 p-2 text-center">
            Press <span class="text-cyan-400 font-bold">SPACE</span> or <span class="text-cyan-400 font-bold">click</span> to FLIP TRACKS!
            <span class="sm:hidden block">(Tap canvas to flip)</span>
        </div>
        
        <div id="rotationTip" class="block sm:hidden text-yellow-400 text-xs mt-2 p-1 text-center bg-gray-800 rounded">
            Tip: Rotate your screen horizontally for a better experience!
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM ELEMENTS ---
            const $ = id => document.getElementById(id);
            const D = {
                canvas: $('gameCanvas'), ctx: $('gameCanvas').getContext('2d'),
                scoreDisplay: $('scoreDisplay'), statusDisplay: $('powerupStatusDisplay'),
                gameOverScreen: $('gameOverScreen'), startScreen: $('startScreen'),
                pauseScreen: $('pauseScreen'), finalScore: $('finalScore'),
                restartButton: $('restartButton'), startButton: $('startButton'),
                goHomeButton: $('goHomeButton'), pauseButton: $('pauseButton'),
                mobileFireButton: $('mobileFireButton'), muteToggle: $('muteToggle'),
                customShipUpload: $('customShipUpload'), customUploadContainer: $('customUploadContainer'),
                uploadMessage: $('uploadMessage'), shapeRadios: document.querySelectorAll('input[name="shape"]'),
                highScoreDisplay: $('highScoreDisplay')
            };

            // --- GAME CONSTANTS & STATE ---
            const ASPECT_RATIO = 2.0;
            const MARGIN_FROM_EDGE = 20;
            const INVINCIBILITY_DURATION = 600; // 10s @ 60fps
            const GUN_DURATION = 900; // 15s @ 60fps
            const MIN_POWERUP_FRAMES = 720;
            const MAX_POWERUP_FRAMES = 1080;
            const INITIAL_OBSTACLE_SPEED = 4;
            const ACCELERATION_RATE = 0.0001;
            const STAR_LAYERS = [ { count: 40, maxRadius: 1.0, baseSpeed: 0.5, color: '#A9A9A9' }, { count: 20, maxRadius: 1.5, baseSpeed: 1.5, color: '#FFFFFF' }, { count: 10, maxRadius: 2.0, baseSpeed: 2.5, color: '#ADD8E6' } ];
            const PLANET_COLORS = ['#f43f5e', '#a78bfa', '#0ea5e9', '#22c55e', '#fbbf24'];

            let gameRunning = false, isPaused = false, score = 0, scoreInterval = 0;
            let obstacleSpeed = INITIAL_OBSTACLE_SPEED, frameCounter = 0, obstacleSpawnRate = 120;
            let floorY, ceilingY, SCALE_FACTOR = 1;

            let customPlayerImage = null;
            let isInvincible = false, invincibilityFrames = 0;
            let hasGunPowerup = false, gunFrames = 0;
            let powerupSpawnCounter = getRandomPowerupFrames();
            let obstacles = [], powerups = [], bullets = [], explosions = [], trails = [];
            let cameraShake = { duration: 0, magnitude: 0 };
            let isMuted = D.muteToggle.checked;

            // --- FIREBASE SETUP ---
            let db, userId = null, highScore = 0;
            const HIGHSCORE_PATH = `artifacts/${typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'}/public/data/astroDashScores/highScore`;
            
            function initializeFirebase() {
                try {
                    setLogLevel('error'); // Reduced log level
                    const app = initializeApp(typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {});
                    db = getFirestore(app);
                    const auth = getAuth(app);
                    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                    (async () => {
                        if (initialAuthToken) await signInWithCustomToken(auth, initialAuthToken);
                        else await signInAnonymously(auth);

                        onAuthStateChanged(auth, user => {
                            userId = user ? user.uid : crypto.randomUUID();
                            setupHighScoreListener();
                        });
                    })();
                } catch (e) { console.error("Firebase Init Failed:", e); }
            }

            function setupHighScoreListener() {
                onSnapshot(doc(db, HIGHSCORE_PATH), docSnap => {
                    highScore = docSnap.exists() ? (docSnap.data().value || 0) : 0;
                    D.highScoreDisplay.textContent = `HI: ${highScore}`;
                }, e => console.error("Error listening to high score:", e));
            }

            async function updateHighScore(newScore) {
                if (newScore > highScore && db) {
                    highScore = newScore;
                    D.highScoreDisplay.textContent = `HI: ${highScore}`;
                    try {
                        await setDoc(doc(db, HIGHSCORE_PATH), { value: newScore, userId, lastUpdated: new Date() }, { merge: true });
                    } catch (e) { console.error("Error updating high score:", e); }
                }
            }

            // --- AUDIO SETUP (TONE.JS) ---
            let flipSynth, hitSynth, collectSynth, gameOverSynth, audioContextStarted = false;
            
            function initAudio() {
                flipSynth = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                hitSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 } }).toDestination();
                collectSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination();
                gameOverSynth = new Tone.MembraneSynth({ pitchDecay: 0.02, octaves: 1, envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.5 } }).toDestination();
                D.muteToggle.addEventListener('change', () => { isMuted = D.muteToggle.checked; });
                document.body.addEventListener('click', () => { if (!audioContextStarted) { Tone.start(); audioContextStarted = true; } }, { once: true });
            }

            function playSound(synth, note) {
                if (audioContextStarted && !isMuted) synth.triggerAttackRelease(note, "4n");
            }
            
            function playCollectSound() {
                if (audioContextStarted && !isMuted) collectSynth.triggerAttackRelease(["C5", "E5", "G5"], "16n");
            }

            // --- RESIZING & SCALING ---
            function resizeCanvas() {
                const { clientWidth, clientHeight } = $('gameContentWrapper');
                const [contentWidth, contentHeight] = [clientWidth - 20, clientHeight - 20];
                
                let calculatedWidth, calculatedHeight;
                if (contentWidth / contentHeight > ASPECT_RATIO) {
                    calculatedHeight = contentHeight;
                    calculatedWidth = contentHeight * ASPECT_RATIO;
                } else {
                    calculatedWidth = contentWidth;
                    calculatedHeight = contentWidth / ASPECT_RATIO;
                }

                D.canvas.width = calculatedWidth;
                D.canvas.height = calculatedHeight;
                SCALE_FACTOR = calculatedWidth / 500;
                
                floorY = D.canvas.height - MARGIN_FROM_EDGE * SCALE_FACTOR;
                ceilingY = MARGIN_FROM_EDGE * SCALE_FACTOR;
                
                player.width = Math.max(25, D.canvas.width / 20);
                player.height = player.width;
                player.flipTargetY = player.isUpsideDown ? ceilingY : (floorY - player.height);
                if (!gameRunning) player.y = player.flipTargetY;

                createStars(); createPlanets(); createNebulaParticles();
                if (!gameRunning && !D.startScreen.classList.contains('hidden')) drawInitialScreen();
            }
            window.addEventListener('resize', resizeCanvas);

            // --- GAME CLASSES ---

            class Player {
                x = 50; y = 0; width = 25; height = 25; isUpsideDown = false; shape = 'square'; color = '#0ff';
                flipTargetY = 0; flipStep = 20;

                draw() {
                    const [hW, hH] = [this.width / 2, this.height / 2];
                    const flash = isInvincible && Math.floor(invincibilityFrames / 5) % 2 === 0;

                    if (this.shape === 'custom' && customPlayerImage && customPlayerImage.complete) {
                        D.ctx.save();
                        if (flash) D.ctx.filter = 'brightness(200%) drop-shadow(0 0 10px white)';
                        D.ctx.drawImage(customPlayerImage, this.x, this.y, this.width, this.height);
                        D.ctx.restore();
                        return;
                    }
                    
                    D.ctx.save();
                    const drawColor = flash ? '#FFFFFF' : (this.isUpsideDown ? '#f97316' : this.color);
                    D.ctx.fillStyle = drawColor; D.ctx.shadowColor = drawColor; D.ctx.shadowBlur = flash ? 25 : 15;
                    
                    if (this.shape === 'square') D.ctx.fillRect(this.x, this.y, this.width, this.height);
                    else if (this.shape === 'circle') {
                        D.ctx.beginPath(); D.ctx.arc(this.x + hW, this.y + hH, hW, 0, Math.PI * 2); D.ctx.fill();
                    } else if (this.shape === 'triangle') {
                        D.ctx.beginPath();
                        D.ctx.moveTo(this.x + this.width, this.y + hH); D.ctx.lineTo(this.x, this.y + this.height);
                        D.ctx.lineTo(this.x, this.y); D.ctx.closePath(); D.ctx.fill();
                    }
                    D.ctx.restore();
                }

                update() {
                    if (gameRunning && !isPaused && frameCounter % 3 === 0) trails.push(new EngineTrail(this.x + this.width/4, this.y + this.height/2, this.color));
                    
                    if (this.y !== this.flipTargetY) {
                        const direction = Math.sign(this.flipTargetY - this.y);
                        this.y += direction * this.flipStep * SCALE_FACTOR;
                        
                        if (direction > 0 && this.y >= this.flipTargetY || direction < 0 && this.y <= this.flipTargetY) {
                            this.y = this.flipTargetY;
                        }
                    }
                }

                switchTrack() {
                    if (Math.abs(this.y - this.flipTargetY) < 1) {
                        playSound(flipSynth, "4n");
                        this.isUpsideDown = !this.isUpsideDown;
                        this.flipTargetY = this.isUpsideDown ? ceilingY : (floorY - this.height);
                    }
                }
            }

            class EngineTrail {
                constructor(x, y, color) { this.x = x; this.y = y; this.radius = 2 * SCALE_FACTOR; this.life = 15; this.color = color; }
                draw() {
                    const opacity = this.life / 15;
                    D.ctx.fillStyle = this.color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
                    D.ctx.beginPath(); D.ctx.arc(this.x, this.y, this.radius * (this.life / 15), 0, Math.PI * 2); D.ctx.fill();
                }
                update() {
                    this.x -= obstacleSpeed * SCALE_FACTOR * 0.5;
                    return this.life-- <= 0;
                }
            }

            class Explosion {
                constructor(x, y, radius) { this.x = x; this.y = y; this.radius = radius; this.maxRadius = radius * 3; this.life = 0; this.maxLife = 15; this.color = '255, 100, 0'; }
                draw() {
                    const progress = this.life / this.maxLife;
                    const currentRadius = this.radius + (this.maxRadius - this.radius) * progress;
                    const opacity = 1 - progress;
                    D.ctx.save();
                    D.ctx.beginPath(); D.ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                    D.ctx.fillStyle = `rgba(${this.color}, ${opacity})`;
                    D.ctx.shadowColor = `rgba(${this.color}, ${opacity})`; D.ctx.shadowBlur = currentRadius / 2;
                    D.ctx.fill(); D.ctx.restore();
                }
                update() { return this.life++ > this.maxLife; }
            }

            class Obstacle {
                constructor() {
                    this.width = (15 + Math.random() * 15) * SCALE_FACTOR; this.height = this.width; this.x = D.canvas.width;
                    this.track = Math.random() < 0.5 ? 0 : 1;
                    const isDark = Math.random() < 0.5;
                    this.color = isDark ? '#374151' : '#a1a1aa';
                    this.detailColor = isDark ? '#1f2937' : '#6b7280';
                    this.rotation = Math.random() * 2 * Math.PI;
                    this.rotationSpeed = (Math.random() * 0.05 + 0.01) * (Math.random() < 0.5 ? 1 : -1) * SCALE_FACTOR * 0.5;
                    this.y = this.track === 0 ? floorY - this.height : ceilingY;
                }
                draw() {
                    const [cx, cy] = [this.x + this.width / 2, this.y + this.height / 2];
                    D.ctx.save(); D.ctx.translate(cx, cy); D.ctx.rotate(this.rotation);
                    D.ctx.fillStyle = this.color; D.ctx.beginPath(); D.ctx.arc(0, 0, this.width / 2, 0, Math.PI * 2); D.ctx.fill();
                    D.ctx.fillStyle = this.detailColor; D.ctx.beginPath(); D.ctx.arc(this.width * 0.25, this.height * 0.25, 3 * SCALE_FACTOR, 0, Math.PI * 2); D.ctx.fill();
                    D.ctx.restore();
                }
                update() {
                    this.x -= obstacleSpeed * SCALE_FACTOR;
                    this.rotation += this.rotationSpeed;
                }
            }
            
            class Powerup {
                constructor(xPos) {
                    this.width = (15 + Math.random() * 5) * SCALE_FACTOR; this.height = this.width; this.x = xPos;
                    this.track = Math.random() < 0.5 ? 0 : 1;
                    this.y = this.track === 0 ? floorY - this.height : ceilingY;
                }
                update() { this.x -= obstacleSpeed * SCALE_FACTOR; }
            }

            class Star extends Powerup {
                draw() {
                    D.ctx.save(); D.ctx.fillStyle = '#FFD700'; D.ctx.shadowColor = '#FFD700'; D.ctx.shadowBlur = 15 * SCALE_FACTOR;
                    const [r, cx, cy, points, outerR, innerR] = [this.width / 2, this.x + this.width / 2, this.y + this.width / 2, 5, this.width / 2, this.width / 4];
                    D.ctx.beginPath();
                    for (let i = 0; i < points * 2; i++) {
                        const currentR = i % 2 === 0 ? outerR : innerR;
                        const angle = (Math.PI / points) * i;
                        const [x, y] = [cx + currentR * Math.cos(angle - Math.PI / 2), cy + currentR * Math.sin(angle - Math.PI / 2)];
                        i === 0 ? D.ctx.moveTo(x, y) : D.ctx.lineTo(x, y);
                    }
                    D.ctx.closePath(); D.ctx.fill(); D.ctx.restore();
                }
                collect() { isInvincible = true; invincibilityFrames = INVINCIBILITY_DURATION; }
            }

            class GunPowerup extends Powerup {
                draw() {
                    D.ctx.save(); D.ctx.fillStyle = '#ff6600'; D.ctx.shadowColor = '#ff6600'; D.ctx.shadowBlur = 15 * SCALE_FACTOR;
                    const [w, h, hH] = [this.width, this.height, this.height / 2];
                    D.ctx.beginPath();
                    D.ctx.fillRect(this.x, this.y, w * 0.7, h); // Body
                    D.ctx.moveTo(this.x + w * 0.7, this.y); D.ctx.lineTo(this.x + w * 1.2, this.y + hH);
                    D.ctx.lineTo(this.x + w * 0.7, this.y + h); D.ctx.closePath(); D.ctx.fill(); // Tip
                    D.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)'; D.ctx.fillRect(this.x + w * 0.1, this.y, w * 0.2, h * 0.2); // Fin
                    D.ctx.restore();
                }
                collect() { hasGunPowerup = true; gunFrames = GUN_DURATION; D.mobileFireButton.classList.remove('hidden'); }
            }

            class Bullet {
                constructor(p) {
                    this.width = 10 * SCALE_FACTOR; this.height = 3 * SCALE_FACTOR; this.x = p.x + p.width;
                    this.y = p.y + p.height / 2 - this.height / 2; this.speed = 15; this.color = '#ff0000';
                }
                draw() {
                    D.ctx.save(); D.ctx.fillStyle = this.color; D.ctx.shadowColor = this.color;
                    D.ctx.shadowBlur = 5 * SCALE_FACTOR; D.ctx.fillRect(this.x, this.y, this.width, this.height); D.ctx.restore();
                }
                update() { this.x += this.speed * SCALE_FACTOR; }
            }
            
            const player = new Player();

            // --- DRAWING FUNCTIONS ---

            let stars = [], planets = [], nebulaParticles = [];
            const sunMoon = { x: 0, y: 0, radius: 0, colorStart: { r: 255, g: 200, b: 0 }, colorEnd: { r: 150, g: 200, b: 255 }, speed: 0.03, isDrawn: false };
            
            function createStars() { stars = STAR_LAYERS.flatMap(l => Array.from({ length: l.count }, () => ({ x: Math.random() * D.canvas.width, y: Math.random() * D.canvas.height, radius: (Math.random() * l.maxRadius + 0.5) * SCALE_FACTOR, baseSpeed: l.baseSpeed, color: l.color }))); }
            function drawStars() {
                const speedFactor = obstacleSpeed / INITIAL_OBSTACLE_SPEED;
                stars.forEach(s => {
                    D.ctx.fillStyle = s.color; D.ctx.beginPath(); D.ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2); D.ctx.fill();
                    s.x -= s.baseSpeed * speedFactor * SCALE_FACTOR;
                    if (s.x < 0) { s.x = D.canvas.width; s.y = Math.random() * D.canvas.height; }
                });
            }

            function createPlanets() {
                planets = Array.from({ length: 3 }, () => {
                    const radius = (20 + Math.random() * 50) * SCALE_FACTOR;
                    return {
                        x: D.canvas.width + Math.random() * D.canvas.width * 2, y: Math.random() * D.canvas.height, radius,
                        color: PLANET_COLORS[Math.floor(Math.random() * PLANET_COLORS.length)],
                        speed: 0.1 + Math.random() * 0.3, hasRings: Math.random() > 0.7, ringTilt: Math.random() * Math.PI / 4,
                        ringWidth: (10 + Math.random() * 20) * SCALE_FACTOR, moon: Math.random() > 0.5 ? { dist: (70 + Math.random() * 30) * SCALE_FACTOR, radius: (5 + Math.random() * 10) * SCALE_FACTOR, angle: Math.random() * Math.PI * 2, speed: 0.05 + Math.random() * 0.05, color: '#e0e0e0' } : null
                    };
                });
            }
            function drawPlanets() {
                const speedFactor = obstacleSpeed / INITIAL_OBSTACLE_SPEED;
                planets.forEach(p => {
                    // Draw Rings
                    if (p.hasRings) {
                        D.ctx.save(); D.ctx.translate(p.x, p.y); D.ctx.rotate(p.ringTilt);
                        D.ctx.beginPath(); D.ctx.ellipse(0, 0, p.radius * 1.5, p.ringWidth / 2, 0, 0, Math.PI * 2);
                        D.ctx.strokeStyle = p.color + '80'; D.ctx.lineWidth = 2 * SCALE_FACTOR; D.ctx.stroke(); D.ctx.restore();
                    }
                    // Draw Main Planet
                    D.ctx.fillStyle = p.color; D.ctx.beginPath(); D.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); D.ctx.fill();
                    // Draw Moon
                    if (p.moon) {
                        p.moon.angle += p.moon.speed * speedFactor;
                        const [mX, mY] = [p.x + p.moon.dist * Math.cos(p.moon.angle), p.y + p.moon.dist * Math.sin(p.moon.angle)];
                        D.ctx.fillStyle = p.moon.color; D.ctx.beginPath(); D.ctx.arc(mX, mY, p.moon.radius, 0, Math.PI * 2); D.ctx.fill();
                    }
                    p.x -= p.speed * speedFactor * SCALE_FACTOR;
                    if (p.x + p.radius < 0) { // Reset planet position
                        const newP = createPlanets()[0]; // Re-use planet creation logic
                        Object.assign(p, newP, { x: D.canvas.width + Math.random() * D.canvas.width * 2 });
                    }
                });
            }

            function createNebulaParticles() {
                nebulaParticles = Array.from({ length: 50 }, () => ({
                    x: Math.random() * D.canvas.width, y: Math.random() * D.canvas.height,
                    radius: (Math.random() * 15 + 5) * SCALE_FACTOR,
                    color: `rgba(0, 255, 255, ${Math.random() * 0.05 + 0.01})`, speed: 0.05 + Math.random() * 0.15
                }));
            }
            function drawNebula() {
                const speedFactor = obstacleSpeed / INITIAL_OBSTACLE_SPEED;
                nebulaParticles.forEach(p => {
                    D.ctx.fillStyle = p.color; D.ctx.beginPath(); D.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); D.ctx.fill();
                    p.x -= p.speed * speedFactor * SCALE_FACTOR;
                    if (p.x < -p.radius) { p.x = D.canvas.width + p.radius + Math.random() * D.canvas.width; p.y = Math.random() * D.canvas.height; }
                });
            }
            
            function drawSunMoon(currentScore) {
                if (!sunMoon.isDrawn && sunMoon.x < D.canvas.width * 1.5) sunMoon.isDrawn = true;
                
                if (sunMoon.isDrawn) {
                    const progress = Math.min(currentScore, 2000) / 2000;
                    const [r, g, b] = ['r', 'g', 'b'].map(c => Math.floor(sunMoon.colorStart[c] + (sunMoon.colorEnd[c] - sunMoon.colorStart[c]) * progress));
                    sunMoon.x -= sunMoon.speed * (obstacleSpeed / INITIAL_OBSTACLE_SPEED) * SCALE_FACTOR;
                    sunMoon.radius = D.canvas.width * 0.15;

                    D.ctx.save();
                    D.ctx.beginPath(); D.ctx.arc(sunMoon.x, sunMoon.y, sunMoon.radius, 0, Math.PI * 2);
                    D.ctx.fillStyle = `rgb(${r},${g},${b})`;
                    D.ctx.shadowColor = `rgba(${r},${g},${b}, 0.7)`; D.ctx.shadowBlur = sunMoon.radius / 2;
                    D.ctx.fill(); D.ctx.restore();
                    
                    if (sunMoon.x + sunMoon.radius < 0) {
                        sunMoon.x = D.canvas.width * 2 + Math.random() * D.canvas.width; sunMoon.y = D.canvas.height * 0.2;
                        sunMoon.isDrawn = false;
                    }
                }
            }

            function drawBackground(currentScore) {
                const progress = Math.min(currentScore, 1500) / 1500;
                const luminosity = 5 + (0 - 5) * progress; // From HSL(240, 50%, 5%) to HSL(240, 50%, 0%)
                D.ctx.fillStyle = `hsl(240, 50%, ${luminosity}%)`;
                D.ctx.fillRect(0, 0, D.canvas.width, D.canvas.height);
                drawNebula(); drawPlanets(); drawSunMoon(currentScore);
            }

            function drawTrack(currentScore) {
                const progress = Math.min(currentScore, 1500) / 1500;
                const hue = 180 + (0 - 180) * progress; // From Cyan (180) to Red (0)
                D.ctx.strokeStyle = `hsl(${hue}, 80%, 50%)`;
                D.ctx.lineWidth = 2 * SCALE_FACTOR;
                D.ctx.beginPath();
                D.ctx.moveTo(0, floorY); D.ctx.lineTo(D.canvas.width, floorY);
                D.ctx.moveTo(0, ceilingY); D.ctx.lineTo(D.canvas.width, ceilingY);
                D.ctx.stroke();
            }

            function drawInitialScreen() {
                D.ctx.fillStyle = '#0d1117'; D.ctx.fillRect(0, 0, D.canvas.width, D.canvas.height);
                drawStars(); drawTrack(0); player.draw();
                D.ctx.fillStyle = '#fff'; D.ctx.font = `${Math.min(24, D.canvas.width / 20)}px Inter`; D.ctx.textAlign = 'center';
                if (D.canvas.height > 200) D.ctx.fillText('Choose your ship and click START', D.canvas.width / 2, D.canvas.height / 2);
            }

            // --- UTILITY ---
            function checkCollision(p, o) {
                return p.x < o.x + o.width && p.x + p.width > o.x && p.y < o.y + o.height && p.y + p.height > o.y;
            }
            function getRandomPowerupFrames() { return Math.floor(Math.random() * (MAX_POWERUP_FRAMES - MIN_POWERUP_FRAMES + 1)) + MIN_POWERUP_FRAMES; }

            // --- GAME LOGIC ---
            function gameOver() {
                playSound(gameOverSynth, "C2");
                gameRunning = false; cancelAnimationFrame(gameLoopId);
                D.pauseButton.classList.add('hidden'); D.mobileFireButton.classList.add('hidden');
                D.finalScore.textContent = `Final Score: ${score}`;
                D.gameOverScreen.classList.remove('hidden');
                updateHighScore(score);
            }
            
            function togglePause() {
                if (!gameRunning) return;
                isPaused = !isPaused;
                if (isPaused) {
                    D.pauseScreen.classList.remove('hidden'); D.pauseButton.textContent = 'Resume (P)';
                    D.mobileFireButton.classList.add('hidden');
                } else {
                    D.pauseScreen.classList.add('hidden'); D.pauseButton.textContent = 'Pause (P)';
                    gameLoop();
                }
            }

            function fireBullet() {
                if (hasGunPowerup && gameRunning && !isPaused) {
                    playSound(hitSynth, "C5");
                    const minFireDistance = 10 * SCALE_FACTOR;
                    if (bullets.length === 0 || bullets[bullets.length - 1].x < player.x + player.width - minFireDistance) {
                           bullets.push(new Bullet(player));
                    }
                }
            }

            function resetGame() {
                // Apply customization
                const s = document.querySelector('input[name="shape"]:checked').value;
                player.shape = (s === 'custom' && !customPlayerImage) ? 'square' : s;
                player.color = document.querySelector('input[name="color"]:checked').value;

                // Reset state
                Object.assign(player, { isUpsideDown: false });
                player.flipTargetY = floorY - player.height; player.y = player.flipTargetY;
                
                [obstacles, powerups, bullets, explosions, trails] = [[], [], [], [], []];
                [isInvincible, hasGunPowerup, cameraShake.duration] = [false, false, 0];
                [invincibilityFrames, gunFrames] = [0, 0];
                
                sunMoon.x = D.canvas.width * 2 + Math.random() * D.canvas.width; sunMoon.y = D.canvas.height * 0.2; sunMoon.isDrawn = false;
                
                isPaused = false; powerupSpawnCounter = getRandomPowerupFrames();
                score = 0; scoreInterval = 0; obstacleSpeed = INITIAL_OBSTACLE_SPEED; frameCounter = 0; obstacleSpawnRate = 120;
                
                // Update UI
                D.startScreen.classList.add('hidden'); D.gameOverScreen.classList.add('hidden');
                D.pauseButton.classList.remove('hidden'); D.scoreDisplay.textContent = 'Score: 0';
                D.statusDisplay.textContent = '';
                
                gameRunning = true; gameLoop();
            }

            function goHome() {
                D.gameOverScreen.classList.add('hidden'); D.startScreen.classList.remove('hidden');
                D.pauseButton.classList.add('hidden'); D.mobileFireButton.classList.add('hidden');
                drawInitialScreen();
            }

            function updateGame() {
                if (isInvincible) invincibilityFrames = Math.max(0, invincibilityFrames - 1);
                else isInvincible = false;

                if (hasGunPowerup) gunFrames = Math.max(0, gunFrames - 1);
                else hasGunPowerup = false;

                if (hasGunPowerup) D.mobileFireButton.classList.remove('hidden');
                else D.mobileFireButton.classList.add('hidden');

                let statusText = "";
                if (isInvincible) statusText += `SAFE: ${Math.ceil(invincibilityFrames/60)}s`;
                if (hasGunPowerup) statusText += `${statusText ? " | " : ""}GUN: ${Math.ceil(gunFrames/60)}s (FIRE: Enter)`;
                D.statusDisplay.textContent = statusText;
            }

            function handleCollisions() {
                // Obstacle-Player Collision
                obstacles = obstacles.filter(o => {
                    o.update();
                    if (checkCollision(player, o)) {
                        if (!isInvincible) gameOver();
                        return false; // Remove on hit/collision (even if invincible, bullet/collision logic handles removal)
                    }
                    return o.x + o.width > 0;
                });
                
                // Powerup-Player Collision
                powerups = powerups.filter(p => {
                    p.update();
                    if (checkCollision(player, p)) {
                        playCollectSound();
                        p.collect();
                        powerupSpawnCounter = getRandomPowerupFrames();
                        return false;
                    }
                    return p.x + p.width > 0;
                });

                // Bullet-Obstacle Collision
                bullets = bullets.filter(b => {
                    b.update();
                    let hitIndex = obstacles.findIndex(o => checkCollision(b, o));
                    if (hitIndex !== -1) {
                        const hitO = obstacles.splice(hitIndex, 1)[0];
                        cameraShake = { duration: 10, magnitude: 5 };
                        explosions.push(new Explosion(hitO.x + hitO.width / 2, hitO.y + hitO.height / 2, hitO.width / 2));
                        score += 100;
                        D.scoreDisplay.textContent = `Score: ${score}`;
                        return false; // Remove bullet
                    }
                    return b.x < D.canvas.width;
                });
            }

            function gameLoop() {
                if (!gameRunning || isPaused) return;

                // 1. Draw Background (Clears canvas)
                drawBackground(score);
                
                // 2. Apply Camera Shake
                if (cameraShake.duration > 0) {
                    cameraShake.duration--;
                    const [tx, ty] = [(Math.random() - 0.5) * cameraShake.magnitude * SCALE_FACTOR, (Math.random() - 0.5) * cameraShake.magnitude * SCALE_FACTOR];
                    D.ctx.save(); D.ctx.translate(tx, ty);
                }

                // 3. Draw Stars (Background layer)
                drawStars();
                
                // 4. Update Score & Speed
                frameCounter++; scoreInterval++;
                if (scoreInterval % 5 === 0) { score++; D.scoreDisplay.textContent = `Score: ${score}`; }
                obstacleSpeed += ACCELERATION_RATE;
                if (frameCounter % 500 === 0 && obstacleSpawnRate > 35) obstacleSpawnRate -= 5;
                updateGame(); // Update timers/UI

                // 5. Spawn Logic
                if (frameCounter % Math.round(obstacleSpawnRate) === 0) obstacles.push(new Obstacle());
                if (powerups.length === 0 && powerupSpawnCounter-- <= 0) {
                    const spawnX = D.canvas.width + player.width * 5;
                    const Type = Math.random() < 0.5 ? Star : GunPowerup;
                    powerups.push(new Type(obstacles.length > 0 ? Math.max(spawnX, obstacles[obstacles.length - 1].x + obstacles[obstacles.length - 1].width + player.width * 5) : spawnX));
                }

                // 6. Update, Draw, and Handle Collisions
                trails = trails.filter(t => !t.update()); trails.forEach(t => t.draw());
                player.update(); player.draw();
                
                handleCollisions(); // Performs all collision checks, updates, and removals
                
                obstacles.forEach(o => o.draw()); // Draw remaining obstacles
                powerups.forEach(p => p.draw()); // Draw remaining powerups
                bullets.forEach(b => b.draw()); // Draw remaining bullets
                
                // Draw Explosions (Visual FX)
                explosions = explosions.filter(e => { e.update(); e.draw(); return e.life <= e.maxLife; });
                
                // 7. Draw Track (Foreground)
                drawTrack(score);
                
                // 8. Restore Context (If shaking)
                if (cameraShake.duration > 0) D.ctx.restore();

                // 9. Loop
                gameLoopId = requestAnimationFrame(gameLoop);
            }

            // --- INPUT HANDLERS ---
            const handleAction = (e) => {
                if (isPaused) return;

                const isSpaceOrClick = e.code === 'Space' || e.type === 'click';
                if (!gameRunning && !D.gameOverScreen.classList.contains('hidden')) resetGame(); // Restart
                else if (!gameRunning && !D.startScreen.classList.contains('hidden') && isSpaceOrClick) resetGame(); // Start
                else if (gameRunning && isSpaceOrClick) player.switchTrack(); // Flip
            };
            
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' || e.code === 'ArrowUp') { e.preventDefault(); handleAction(e); }
                else if (e.code === 'Enter') { e.preventDefault(); fireBullet(); }
                else if (e.code === 'KeyP' || e.code === 'Escape') { if (gameRunning && D.startScreen.classList.contains('hidden')) togglePause(); }
            });
            D.canvas.addEventListener('click', (e) => {
                if (gameRunning && isPaused) togglePause();
                else handleAction(e);
            });
            D.mobileFireButton.addEventListener('click', (e) => { e.stopPropagation(); fireBullet(); });
            
            D.startButton.addEventListener('click', resetGame); D.restartButton.addEventListener('click', resetGame);
            D.goHomeButton.addEventListener('click', goHome); D.pauseButton.addEventListener('click', togglePause);

            // --- CUSTOMIZATION LISTENERS ---
            D.shapeRadios.forEach(radio => radio.addEventListener('change', () => {
                D.customUploadContainer.classList.toggle('hidden', radio.value !== 'custom');
                player.shape = radio.value; drawInitialScreen();
            }));

            D.customShipUpload.addEventListener('change', function(e) {
                const file = e.target.files[0]; customPlayerImage = null;
                const [MAX_SIZE, VALID_TYPES] = [400 * 1024, ['image/jpeg', 'image/png', 'image/jpg']];
                
                if (file) {
                    if (file.size > MAX_SIZE) return D.uploadMessage.textContent = 'Error: File size must be under 400KB!', D.uploadMessage.className = 'text-xs mt-1 text-red-400 text-left', D.customShipUpload.value = '';
                    if (!VALID_TYPES.includes(file.type)) return D.uploadMessage.textContent = 'Error: Only JPG or PNG allowed.', D.uploadMessage.className = 'text-xs mt-1 text-red-400 text-left', D.customShipUpload.value = '';

                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = new Image();
                        img.onload = function() {
                            customPlayerImage = img;
                            D.uploadMessage.textContent = `Image loaded: ${file.name}`; D.uploadMessage.className = 'text-xs mt-1 text-green-400 text-left';
                            drawInitialScreen();
                        };
                        img.onerror = function() { D.uploadMessage.textContent = 'Error: Could not load image data.'; D.uploadMessage.className = 'text-xs mt-1 text-red-400 text-left'; }
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                } else { D.uploadMessage.textContent = 'Max 400KB file size.'; D.uploadMessage.className = 'text-xs mt-1 text-gray-400 text-left'; }
            });

            // --- INITIALIZATION ---
            initAudio(); initializeFirebase(); resizeCanvas(); drawInitialScreen();
        });
    </script>
</body>
</html>
